# 알고리즘 학습 노트

## 1. 공통 개념 키워드

- **Level (레벨)**: 현재까지 선택한 횟수 (재귀 깊이).
- **Branch (브랜치)**: 이번 단계에서 가능한 선택지들의 집합.
- **백트래킹**: 선택 → 재귀 호출 → 선택 취소(pop/used 해제) 과정을 반복하며 모든 경우 탐색.
- **가지치기 (Pruning)**: 더 탐색해도 최적해를 갱신할 수 없을 때 탐색을 중단하여 속도를 향상.
- **used 배열**: 순열에서 같은 원소를 중복 선택하지 않도록 관리.
- **start 인자**: 조합에서 오름차순을 유지하고 중복 제거를 위해 사용.

---

## 2. Baby-Gin 판별 (순열 + 백트래킹)

### 문제

- 카드 6장이 주어졌을 때, 앞 3장과 뒤 3장이 각각 **triplet**(같은 수 3개) 또는 **run**(연속된 수 3개)이면 Baby-Gin.

### 전략

1. **Level** = 6 (카드 6장을 모두 뽑을 때까지 탐색).
2. **Branch** = 아직 사용하지 않은 카드들.
3. **used 배열**로 중복 방지 → 6장의 모든 순열 생성.
4. `앞 3장`, `뒤 3장`을 나누어 각각 triplet/run 여부 판정.
5. 둘 다 만족하면 Baby-Gin.
6. 한 번 발견되면 탐색 종료(조기 종료).

### 포인트

- run 판정 시 반드시 정렬해서 연속성 체크.
- 6! = 720가지 순열만 검사하면 되므로 충분히 탐색 가능.

---

## 3. 전자카트 최소합 (TSP 축소판)

### 문제

- 비용 행렬이 주어질 때,
- 0번(사무실)에서 출발 → 1..N-1을 모두 방문 → 다시 0으로 복귀.
- 전체 경로 비용의 최소값을 구하라.

### 전략

1. **Level** = 지금까지 방문한 구역 수 (사무실 제외).
2. **Branch** = 아직 방문하지 않은 구역들.
3. 누적 비용 `cost`를 계속 더하면서 탐색.
4. 기저 조건: 모든 구역을 방문했으면 `+ 복귀 비용`을 합산.
5. `best`와 비교해 최소값 갱신.
6. **Pruning**: 누적 비용이 이미 최소값 이상이면 중단.

### 포인트

- (N-1)! 경우의 수 → N이 12 이하라면 DFS/백트래킹으로 가능.
- 복귀 비용을 빼먹지 않도록 주의.

---

## 4. 격자 최솟값 경로 (오른쪽/아래 이동)

### 문제

- N×N 격자에서 (0,0) → (N-1,N-1)까지 이동.
- 오른쪽 또는 아래로만 이동 가능.
- 이동한 칸들의 합의 최소값 구하기.

### 전략

1. 상태는 좌표 `(y,x)`와 누적합 `sum_v`.
2. **Branch** = 오른쪽(x+1), 아래(y+1).
3. 기저 조건: 끝점에 도달하면 최소값 갱신.
4. **Pruning**: 누적합이 현재 최소값 이상이면 중단.

### 포인트

- DFS/백트래킹으로 풀 수 있고, DP(`dp[y][x]`)로도 효율적으로 가능.

---

## 5. 연습 문제 로드맵

### (1) 스택/문자열 기초

- 10828 스택
- 9012 괄호
- 10773 제로
- 4949 균형잡힌 세상

### (2) 재귀/순열·조합

- 15649 N과 M (1) — 순열 (used 배열)
- 15650 N과 M (2) — 조합 (start 인자)
- 15651 N과 M (3) — 중복 순열
- 11729 하노이 탑 — 재귀 기본

### (3) 그래프 탐색

- 1260 DFS와 BFS
- 2606 바이러스
- 11724 연결 요소의 개수

### (4) 완전탐색/백트래킹 심화

- 14888 연산자 끼워넣기
- 14889 스타트와 링크
- 10971 외판원 순회 2 (TSP, 전자카트와 유사)

---

## 6. 디버깅 팁 & 자주 하는 실수

- `path.pop()` 또는 `used[i]=0`을 빼먹으면 중복/무한루프 발생.
- run 판정 시 정렬 누락 → 연속인데도 False로 판정.
- 전자카트 문제에서 마지막 **복귀 비용** 누락 주의.
- 가지치기 조건을 너무 일찍 넣으면 정답을 놓칠 수 있음 → 항상 `>=` 조건으로 체크.
