# ---------------------------------------------
# 문제 요약 (전자카트 / TSP 축소판)
# - 0(사무실)에서 출발해서 1..N-1 구역을 한 번씩 모두 방문하고
#   다시 0으로 되돌아올 때 드는 총 비용의 최소값을 구하는 문제
# - arr[i][j] : i -> j로 이동하는 비용
# - 완전탐색(DFS) + 백트래킹으로 모든 경로를 만들어보며 최소비용 갱신
# ---------------------------------------------

def dfs(lev, sum_v):
    """
    lev   : 지금까지 방문한 '구역'의 수(깊이, level). 사무실(0)만 있을 때 0부터 시작.
            모든 구역(1..N-1)을 다 방문하면 lev == N-1 이 됨.
    sum_v : 지금까지 이동하며 누적된 비용의 합.
    """
    global min_v, N, arr, path, used

    # (선택적 가지치기) 지금까지의 비용이 이미 최소값 이상이면 더 볼 필요가 없음
    # -> 있으면 빨라지고, 없어도 정답은 맞음 (이 줄이 이해 안되면 주석처리해도 됨)
    if sum_v >= min_v:
        return

    # [기저 조건] 모든 구역을 다 방문했을 때 (사무실 제외 N-1개 방문을 마쳤다는 뜻)
    if lev == N - 1:
        # path[-1] : 현재 경로의 마지막 구역(= 지금 내가 서 있는 곳)
        # arr[path[-1]][0] : 마지막 구역 -> 사무실(0)로 돌아가는 비용
        sum_v += arr[path[-1]][0]   # "마지막 복귀 비용" 반드시 더해줘야 함!
        # 최소값 갱신
        min_v = min(min_v, sum_v)
        return

    # ---------------------------------------------
    # [분기(브랜치) / 다음 방문 후보 탐색]
    # branch, level : N-1
    # - level(깊이)은 총 N-1단계 (구역 1..N-1을 하나씩 채워가기 때문)
    # - 매 단계에서 branch(선택지)는 "아직 방문하지 않은 구역들"이 됨
    # ---------------------------------------------
    for i in range(1, N):  # 0은 사무실이라 제외하고 1..N-1만 후보로 돈다
        if used[i] == 1:   # 이미 방문한 구역이면 스킵 (중복 방문 금지)
            continue

        # [방문 전 준비]
        used[i] = 1        # i 구역 방문 표시
        path.append(i)     # 경로에 i를 추가

        # path[-2] : 직전에 방문했던 구역(= 바로 이전 위치)
        # i        : 이번에 새로 가려는 구역
        # arr[path[-2]][i] : "직전 구역 -> i 구역"으로 이동하는 데 드는 비용
        dfs(lev + 1, sum_v + arr[path[-2]][i])

        # [백트래킹] - 되돌리기 (다른 후보를 시도하기 위해 상태 원복)
        path.pop()
        used[i] = 0


# ------------------------------
# 입력 처리 및 테스트 케이스 실행부
# ------------------------------
T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]

    # 경로/방문 정보 초기화
    path = [0]         # 경로는 항상 사무실(0)에서 시작
    used = [0] * N
    used[0] = 1        # 사무실은 이미 '방문'으로 처리

    # 최소값을 아주 큰 수로 초기화
    min_v = float('inf')

    # DFS 시작: lev=0(사무실만 있는 상태), sum_v=0(아직 이동 없음)
    dfs(0, 0)

    # 결과 출력
    print(f'#{tc} {min_v}')
